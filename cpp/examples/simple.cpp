// simple.cpp
// Run the templatize laz
//

#include "common/common.hpp"
#include "compressor.hpp"
#include "decompressor.hpp"

#include "encoder.hpp"
#include "decoder.hpp"
#include "formats.hpp"

#include <iostream>
#include <memory>

// First, create a simple class to capture data generated by the compressor, this could be anything
// as long as it confirms with the behaviour below.
//
struct SuchStream {
	SuchStream() : buf(), idx(0) {}

	void putBytes(const unsigned char* b, size_t len) {
		while(len --) {
			buf.push_back(*b++);
		}
	}

	void putByte(const unsigned char b) {
		buf.push_back(b);
	}

	unsigned char getByte() {
		return buf[idx++];
	}

	void getBytes(unsigned char *b, int len) {
		for (int i = 0 ; i < len ; i ++) {
			b[i] = getByte();
		}
	}

	std::vector<unsigned char> buf;	// cuz I'm ze faste
	size_t idx;
};

int main() {
	// import namespaces to reduce typing
	//
	using namespace laszip;
	using namespace laszip::formats;

	// Let's say our record looks something like this:
	//
	struct {
		int a;
		short b;
		unsigned short c;
		unsigned int d;
	} data;

	// Create a record compressor to match the description above, sometimes your data may have fields
	// that relate well with each other, in that case you should specify your own custom compressor which will
	// then allow you to use field<data> below for compression
	//
	// For now we'll assume data is not corelated and we would like to compress fields individually
	//
	record_compressor<
		field<int>,
		field<short>,
		field<unsigned short>,
		field<unsigned int> > compressor;

	// Create an object of our stream to which the encoder will write
	//
	SuchStream s;

	// Instantiate the arithmetic encoder
	//
	encoders::arithmetic<SuchStream> encoder(s);

	// Encode some dummy data
	//
	for (int i = 0 ; i < 1000; i ++) {
		data.a = i;
		data.b = static_cast<unsigned short>(i + 10);
		data.c = static_cast<unsigned short>(i + 40000);
		data.d = i + (1 << 31);

		// All compressor cares about is your data as a pointer, it will unpack data
		// automatically based on the fields that were specified and compress them
		//
		compressor.compressWith(encoder, (const char*)&data);
	}

	// Finally terminate the encoder by calling done on it. This will flush out any pending data to output.
	//
	encoder.done();


	// Print some fun stuff about compression
	//
	std::cout << "Points compressed to: " << s.buf.size() << " bytes" << std::endl;

	// Setup a record decompressor the same way as compressor, it will be nice to have a single record definition which
	// would then be re-usable among compressor and decompressor, but work is on going in that direction.  Encoders and Decoders
	// are highly stateful that's why at this point we have separate definitions
	//
	record_decompressor<
		field<int>,
		field<short>,
		field<unsigned short>,
		field<unsigned int> > decompressor;

	// Create a decoder same way as we did with the encoder
	//
	decoders::arithmetic<SuchStream> decoder(s);

	// This time we'd read the values out instead and make sure they match what we pushed in
	//
	for (int i = 0 ; i < 10 ; i ++) {
		// When we decompress data we need to provide where to decode stuff to
		//
		decompressor.decompressWith(decoder, (char *)&data);

		// Finally make sure things match, otherwise bail
		if (data.a != i ||
			data.b != i + 10 ||
			data.c != i + 40000 ||
			data.d != (unsigned int)i + (1 << 31))
			throw std::runtime_error("Failure!");
	}

	// And we're done
	std::cout << "Done!" << std::endl;

	return 0;
}
